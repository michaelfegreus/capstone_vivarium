#ifndef DIGITALSALMON_FADE_INCLUDED
#define DIGITALSALMON_FADE_INCLUDED

// ------------------------------------
// Constants
// ------------------------------------

static const float PI = 3.14159265359;
static const float TAU = 6.28318530718;
static const float DEG2RAD = 0.01745329252;
static const float RAD2DEG = 180 / PI;
static const float MAX_FLOAT = 3.402823466e+38F;

// ------------------------------------
// Defines
// ------------------------------------

#define REMAP_SOFTNESS _Softness /= 500; _Softness = max(0.000001, _Softness);

// ------------------------------------
// Type Definitions
// ------------------------------------

struct ds_appdata {
	float4 vertex : POSITION;
	float2 uv : TEXCOORD0;
};

struct ds_v2f {
	float2 uv : TEXCOORD0;
	float4 vertex : SV_POSITION;
};

// ------------------------------------
// Vertex Program
// ------------------------------------

ds_v2f ds_vert_img(ds_appdata v) {
	ds_v2f o;
	o.vertex = UnityObjectToClipPos(v.vertex);
	o.uv = v.uv;
	return o;
}

// ------------------------------------
// Included Uniforms
// ------------------------------------

uniform sampler2D _MainTex;
uniform float _Delta;
uniform float4 _BaseColor;

// ------------------------------------
// Field Operations
// ------------------------------------

// A small part of the DigitalSalmon field library.
// Many parts of these functions were made possible by iq.

// 'a' - 'b'.
float opSubtraction(float a, float b) {
	return max(-b, a);
}

// 'a' && 'b'
float2 opUnion(float a, float b) {
	return min(a, b);
}

// 'a' > 'b' ? 'a' : 'b'
float opIntersect(float a, float b) {
	return max(a, b);
}

// 2D Circle
float sdSphere(float2 domain, float radius) {
	return length(domain) - radius;
}

// 2D NGon (Triangle, Square, Pentagon...)
float sdNgon(float2 domain, int sides, float radius) {

	float hyp = radius * cos(PI / sides);

	float a = atan2(domain.x, domain.y) + PI;
	float r = TAU / float(sides);
	float d = (cos(floor(0.5 + a / r) * r - a) * length(domain)) - hyp;

	return d;
}

 // 2D Star 
float sdStar(float2 _uv, int _count, float _indent) {
	int segments = _count;
	segments = max(5, segments);
	
	float indent = _indent / 1000;
	indent = clamp(indent,0, 0.1);

	float angle = (atan2(_uv.y, _uv.x) + PI) / TAU; // 0-1
	float segment = angle * segments;
	float segmentI = floor(segment);
	float segmentF = frac(segment);
	angle = (segmentI + 0.5) / segments; 
	if (segmentF > 0.5) {
		angle -= indent;
	}
	else {
		angle += indent;
	}

	angle *= TAU;
	float2 outline = float2(cos(angle), sin(angle));

	float radialField = abs(dot(outline, _uv));
	return radialField;
}

// ------------------------------------
// Utility Functions
// ------------------------------------

float linstep(float low, float high, float x) {

	if (x < low) return 0;
	if (x > high) return 1;
	return abs((x - low) / (low - high));
}

float2 rotate(float2 domain, float angleDegrees) {
	float s = sin(angleDegrees * DEG2RAD);
	float c = cos(angleDegrees * DEG2RAD);

	float tx = domain.x;
	float ty = domain.y;
	domain.x = (c * tx) - (s * ty);
	domain.y = (s * tx) + (c * ty);
	return domain;
}

float2 rotateAround(float2 domain, float2 pivot, float angleDegrees) {
	domain -= pivot;
	domain = rotate(domain, angleDegrees);
	domain += pivot;
	return domain;
}

// ------------------------------------
// Fade Specific
// ------------------------------------

float remapDelta(float delta, float smoothing) {
	delta *= (1 + (2*smoothing));
	delta -= smoothing;
	return delta;
}

float radial01(float2 domain) {
	float field = atan2(domain.y, domain.x);
	field += PI;
	field /= TAU;
	return field;
}

// ------------------------------------
// Gaussian Specific
// ------------------------------------
// All blur kernels are generated by http://dev.theomader.com/gaussian-kernel-calculator/
// At Sigma 5.

#if SHADER_API_GLES
float4 gaussian3(sampler2D tex, float2 uv, float blurDistance) {
	return tex2D(tex, uv);
}
float4 gaussian5(sampler2D tex, float2 uv, float blurDistance) {
	return tex2D(tex, uv);
}
float4 gaussian7(sampler2D tex, float2 uv, float blurDistance) {
	return tex2D(tex, uv);
}
float4 gaussian9(sampler2D tex, float2 uv, float blurDistance) {
	return tex2D(tex, uv);
}
#else
float4 gaussian3(sampler2D tex, float2 uv, float blurDistance) {

	float2 dir = float2(blurDistance, blurDistance);

	float KERNAL[3][3] = {
		{ 0.109634, 0.111842, 0.109634 },
	{ 0.111842, 0.114094, 0.111842 },
	{ 0.109634, 0.111842, 0.109634 }
	};


	float4 blurredOutput = float4(0, 0, 0, 1);

	for (int x = -1; x < 2; x++) {
		for (int y = -1; y < 2; y++) {
			blurredOutput += tex2D(tex, uv + float2(dir.x*x, dir.y*y))*KERNAL[x + 1][y + 1];
		}
	}

	return blurredOutput;
}

float4 gaussian5(sampler2D tex, float2 uv, float blurDistance) {

	float2 dir = float2(blurDistance, blurDistance);

	float KERNAL[5][5] = {
		{ 0.036894, 0.039167, 0.039956, 0.039167, 0.036894 },
	{ 0.039167, 0.041581, 0.042418, 0.041581, 0.039167 },
	{ 0.039956, 0.042418, 0.043272, 0.042418, 0.039956 },
	{ 0.039167, 0.041581, 0.042418, 0.041581, 0.0391679 },
	{ 0.036894, 0.039167, 0.039956, 0.039167, 0.036894 }
	};

	float4 blurredOutput = float4(0, 0, 0, 1);

	for (int x = -2; x < 3; x++) {
		for (int y = -2; y < 3; y++) {
			blurredOutput += tex2D(tex, uv + float2(dir.x*x, dir.y*y))*KERNAL[x + 2][y + 2];
		}
	}

	return blurredOutput;
}

float4 gaussian7(sampler2D tex, float2 uv, float blurDistance) {

	float2 dir = float2(blurDistance, blurDistance);

	//Sigma 5
	float KERNAL[7][7] = {
		{ 0.016641, 0.018385, 0.019518, 0.019911, 0.019518, 0.018385, 0.016641 },
	{ 0.018385, 0.020312, 0.021564, 0.021998, 0.021564, 0.020312, 0.018385 },
	{ 0.019518, 0.021564, 0.022893, 0.023354, 0.022893, 0.021564, 0.019518 },
	{ 0.019911, 0.021998, 0.023354, 0.023824, 0.023354, 0.021998, 0.019911 },
	{ 0.019518, 0.021564, 0.022893, 0.023354, 0.022893, 0.021564, 0.019518 },
	{ 0.018385, 0.020312, 0.021564, 0.021998, 0.021564, 0.020312, 0.018385 },
	{ 0.016641, 0.018385, 0.019518, 0.019911, 0.019518, 0.018385, 0.016641 }
	};


	float4 blurredOutput = float4(0, 0, 0, 1);

	for (int x = -3; x < 4; x++) {
		for (int y = -3; y < 4; y++) {
			blurredOutput += tex2D(tex, uv + float2(dir.x*x, dir.y*y))*KERNAL[x + 3][y + 3];
		}
	}

	return blurredOutput;
}

float4 gaussian9(sampler2D tex, float2 uv, float blurDistance) {

	float2 dir = float2(blurDistance, blurDistance);

	//Sigma 5
	float KERNAL[9][9] = {
		{ 0.008397, 0.009655, 0.010667, 0.011324, 0.011552, 0.011324, 0.010667, 0.009655, 0.008397 },
	{ 0.009655, 0.0111, 0.012264, 0.013019, 0.013282, 0.013019, 0.012264, 0.0111, 0.009655 },
	{ 0.010667, 0.012264, 0.013549, 0.014384, 0.014674, 0.014384, 0.013549, 0.012264, 0.010667 },
	{ 0.011324, 0.013019, 0.014384, 0.01527, 0.0155780, .01527, 0.014384, 0.013019, 0.011324 },
	{ 0.011552, 0.013282, 0.014674, 0.015578, 0.015891, 0.015578, 0.014674, 0.013282, 0.011552 },
	{ 0.011324, 0.013019, 0.014384, 0.01527, 0.0155780, .01527, 0.014384, 0.013019, 0.011324 },
	{ 0.010667, 0.012264, 0.013549, 0.014384, 0.014674, 0.014384, 0.013549, 0.012264, 0.010667 },
	{ 0.009655, 0.0111, 0.012264, 0.013019, 0.013282, 0.013019, 0.012264, 0.0111, 0.009655 },
	{ 0.008397, 0.009655, 0.010667, 0.011324, 0.011552, 0.011324, 0.010667, 0.009655, 0.008397 }
	};

	float4 blurredOutput = float4(0, 0, 0, 1);

	for (int x = -4; x < 5; x++) {
		for (int y = -4; y < 5; y++) {
			blurredOutput += tex2D(tex, uv + float2(dir.x*x, dir.y*y))*KERNAL[x + 4][y + 4];
		}
	}

	return blurredOutput;
}
#endif // GLES

#endif // DIGITALSALMON_FADE_INCLUDED